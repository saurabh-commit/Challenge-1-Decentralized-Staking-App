{"ast":null,"code":"import { useCallback, useEffect, useRef } from 'react';\nconst DEBUG = false;\n/**\r\n * A combination of useOnBlock and usePoller\r\n * helper hook to call a function regularly at time intervals when the block changes\r\n * @param provider ethers/web3 provider\r\n * @param callback any function\r\n * @param args function parameters\r\n */\n\n/**\r\n * A combination of useOnBlock and usePoller\r\n * - the hook will invoke a callback regularly on the \"block\" event.  If a pollTime is provided,\r\n * it will use that instead.\r\n * - the hook will invoke the callback when the leadTrigger changes state to true as a leading invokation\r\n * @param callback\r\n * @param options pollTime?: number; provider?: Provider | undefined; leadTrigger?: boolean;\r\n * @param args varargs callback function arguments\r\n */\n\nexport const useOnRepetition = (callback, options, ...args) => {\n  const polling = (options === null || options === void 0 ? void 0 : options.pollTime) && options.pollTime > 0;\n  const leadingCall = useRef(true); // save the input function provided\n\n  const callFunctionWithArgs = useCallback(() => {\n    if (callback) {\n      if (args && args.length > 0) {\n        void callback(...args);\n      } else {\n        void callback();\n      }\n    }\n  }, [callback, args]); // Turn on the listener if we have a function & a provider\n\n  const listener = useCallback(_blockNumber => {\n    if (DEBUG) console.log('listen block event', _blockNumber, ...args);\n    if (options.provider) callFunctionWithArgs();\n  }, [callFunctionWithArgs, options.provider, args]); // connect a listener for block changes\n\n  useEffect(() => {\n    if (options.provider && !polling) {\n      if (DEBUG) console.log('register block event', ...args);\n      options.provider.addListener('block', listener);\n      return () => {\n        var _a;\n\n        (_a = options === null || options === void 0 ? void 0 : options.provider) === null || _a === void 0 ? void 0 : _a.removeListener('block', listener);\n      };\n    } else {\n      return () => {\n        /* do nothing */\n      };\n    }\n  }, [options.provider, polling, listener, args]); // Set up the interval if its using polling\n\n  useEffect(() => {\n    const tick = () => {\n      if (DEBUG) console.log('polling: call function');\n      callFunctionWithArgs();\n    };\n\n    if (polling) {\n      const id = setInterval(tick, options.pollTime);\n      return () => {\n        clearInterval(id);\n      };\n    }\n  }, [options.pollTime, polling, callFunctionWithArgs]); // call if triggered by extra watch, however only on inital call\n\n  useEffect(() => {\n    if (options.leadingTrigger && callFunctionWithArgs != null && (leadingCall === null || leadingCall === void 0 ? void 0 : leadingCall.current) === true) {\n      leadingCall.current = false;\n      callFunctionWithArgs();\n    }\n  }, [options.leadingTrigger, callFunctionWithArgs]);\n};","map":{"version":3,"sources":["/Users/saurabhshukl@juniper.net/Documents/Consensys/scaffold-eth/challenge-1-decentralized-staking/node_modules/eth-hooks/useOnRepetition.js"],"names":["useCallback","useEffect","useRef","DEBUG","useOnRepetition","callback","options","args","polling","pollTime","leadingCall","callFunctionWithArgs","length","listener","_blockNumber","console","log","provider","addListener","_a","removeListener","tick","id","setInterval","clearInterval","leadingTrigger","current"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\r\nconst DEBUG = false;\r\n/**\r\n * A combination of useOnBlock and usePoller\r\n * helper hook to call a function regularly at time intervals when the block changes\r\n * @param provider ethers/web3 provider\r\n * @param callback any function\r\n * @param args function parameters\r\n */\r\n/**\r\n * A combination of useOnBlock and usePoller\r\n * - the hook will invoke a callback regularly on the \"block\" event.  If a pollTime is provided,\r\n * it will use that instead.\r\n * - the hook will invoke the callback when the leadTrigger changes state to true as a leading invokation\r\n * @param callback\r\n * @param options pollTime?: number; provider?: Provider | undefined; leadTrigger?: boolean;\r\n * @param args varargs callback function arguments\r\n */\r\nexport const useOnRepetition = (callback, options, ...args) => {\r\n    const polling = (options === null || options === void 0 ? void 0 : options.pollTime) && options.pollTime > 0;\r\n    const leadingCall = useRef(true);\r\n    // save the input function provided\r\n    const callFunctionWithArgs = useCallback(() => {\r\n        if (callback) {\r\n            if (args && args.length > 0) {\r\n                void callback(...args);\r\n            }\r\n            else {\r\n                void callback();\r\n            }\r\n        }\r\n    }, [callback, args]);\r\n    // Turn on the listener if we have a function & a provider\r\n    const listener = useCallback((_blockNumber) => {\r\n        if (DEBUG)\r\n            console.log('listen block event', _blockNumber, ...args);\r\n        if (options.provider)\r\n            callFunctionWithArgs();\r\n    }, [callFunctionWithArgs, options.provider, args]);\r\n    // connect a listener for block changes\r\n    useEffect(() => {\r\n        if (options.provider && !polling) {\r\n            if (DEBUG)\r\n                console.log('register block event', ...args);\r\n            options.provider.addListener('block', listener);\r\n            return () => {\r\n                var _a;\r\n                (_a = options === null || options === void 0 ? void 0 : options.provider) === null || _a === void 0 ? void 0 : _a.removeListener('block', listener);\r\n            };\r\n        }\r\n        else {\r\n            return () => {\r\n                /* do nothing */\r\n            };\r\n        }\r\n    }, [options.provider, polling, listener, args]);\r\n    // Set up the interval if its using polling\r\n    useEffect(() => {\r\n        const tick = () => {\r\n            if (DEBUG)\r\n                console.log('polling: call function');\r\n            callFunctionWithArgs();\r\n        };\r\n        if (polling) {\r\n            const id = setInterval(tick, options.pollTime);\r\n            return () => {\r\n                clearInterval(id);\r\n            };\r\n        }\r\n    }, [options.pollTime, polling, callFunctionWithArgs]);\r\n    // call if triggered by extra watch, however only on inital call\r\n    useEffect(() => {\r\n        if (options.leadingTrigger && callFunctionWithArgs != null && (leadingCall === null || leadingCall === void 0 ? void 0 : leadingCall.current) === true) {\r\n            leadingCall.current = false;\r\n            callFunctionWithArgs();\r\n        }\r\n    }, [options.leadingTrigger, callFunctionWithArgs]);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}